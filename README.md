# Compilers Course Code Collection

This is a collections of codes used in a Compilers course taught by me at Uniritter (2016-1 and 2017-1). The codes showcase some parsing techniques and the usage of antlr as a parser. It also shows how to associate semantic actions with rules of the grammar and how to generate code.

This repo hosts the code for StackVM (a virtual machine used as code generation target) and the reference code MMMLc (the compiler for the MMML language, used in the courses).

- [S-Expression Parsers](./SExpr) : A collection of parsers for S-Expressions.

- [StackVM](./StackVM) : A stack virtual machine, inspired in JVM but with way less features.

- [Math Expression Parser](./MathExprParser) : A parser for mathematical expressions. It uses antlr with the *Listener* pattern to generate code for StackVM

- [MMML Compiler](./MMML) : A compiler for the MMML language. It used antlr and the Visitor pattern to generate code for StackVM.

# JavaScript files for the Playgrounds

The javascript files present in the git tree are generated from C++ sources with [EMScripten](https://github.com/juj/emsdk). The git-managed versions aren't used in the zip-file generated by CMake (rules `mmml.zip`, `stackvm.zip`), but they make it easier to test the generated HTMLs (from org-mode).

This code was tested with
- sdk-tag-1.37.18-64bit (compiled from source)
- emscripten-tag-1.37.18-64bit (compiled from source)
- node-4.1.1-64bit (downloaded)

In order to build the javascript:

1. **Prepare the Build Environment**
    1. Download and install emscripten in some path (e.g. `./emscripten`)
    2. Install and/or Activate a SDK environment (may take a while)
      ```sh
      emsdk install node-4.1.1-64bit clang-tag-e1.37.18-64bit emscripten-tag-1.37.18-64bit sdk-tag-1.37.18-64bit
      emsdk activate sdk-tag-1.37.18-64bit
      ```
    2. Create a build directory
      ```sh
      mkdir JS
      cd JS
      ```
    3. Load the emsdk environment:
      ```sh
      source ../emsdk-portable/emsdk_env.sh
    ```
    4. Execute cmake to prepare the build environment
      ```sh
      emconfigure cmake ..
      ```
2. **Compile**: Just call `make` in the previously configures build directory. Since CMake has already cached the commands it should use, there's no need to wrap `make` with `emmake` or to `source` the sdk environment.
   ```sh
   cd JS
   make
   ```

The generated javascript files are not executable, but they export a `parse_script_c` symbol -- the function implemented in C++.
```sh
if(${CMAKE_CXX_COMPILER} MATCHES "em\\+\\+")
  set(CMAKE_EXE_LINKER_FLAGS "-s EXPORTED_FUNCTIONS=\"['_parse_string_c']\"")
endif()
```

These files can be used by a browser, such as in the following example:
```html
<script type="text/javascript" src="./sparser.js"></script>

<script>
  doParse = function(text) {
      r = ccall('parse_string_c', 'string', ['string'], [text]);
      return r;
  };

  parseSource = function() {
      d_ta = document.getElementById('esource');
      d_res = document.getElementById('result');

      res = doParse(d_ta.value);

      d_res.value = res;
  };
</script>
```

## DO NOT USE -- Hand Compiling a C++ code to JavaScript:
```sh
source emsdk_env.sh
emsdk activate sdk-tag-1.37.18-64bit
emcc -o sparser2.js sparser_2.cpp -s EXPORTED_FUNCTIONS="['_parse_string_c']"
```

If one wants to generate the console web app:
```sh
emcc -o sparser_console.html sparser_2.cpp
```
