<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt" xml:lang="pt">
<head>
<!-- 2017-10-18 qua 17:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Linguagem \(\mu\)mML</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Prof. Rodrigo Kassick" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript" src="./mmmlc.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Linguagem \(\mu\)mML</h1>

<script>
 doParse = function(text)
 {
     r = ccall('parse_string_c', 'string', ['string'], [text]);
     return r;
 };

 parseSource = function()
 {
     d_ta = document.getElementById('esource');
     d_res = document.getElementById('result');

     res = doParse(d_ta.value);

     d_res.value = res;
 };
</script>

<p>
<b>Código Fonte:</b>
</p>

<textarea name="source" id="esource" rows="10" cols="70">
def main =
let i = read_int _,
    s = str i,
    msg = "voce digitou: " :: s :: ['\n']
in
    print msg
</textarea>

<p>

<button type="button" onclick='parseSource()'>Parse</button>

<p>

<p>
<b>Resultado:</b>
</p>

<textarea id="result" rows="10" cols="70"></textarea>

<div id="outline-container-org09b7263" class="outline-2">
<h2 id="org09b7263">A Linguagem Micro Mini ML</h2>
<div class="outline-text-2" id="text-org09b7263">
<p>
\(\mu\)mML é uma linguagem da família ML (F#, OCaML, Nemerle, dentre outras). Ela é uma linguagem funcional <i>pura</i> &#x2013; isto é, cada variável é atribuída uma única vez, não sendo permitidas alterações posteriores. Iterações devem ser feitas utilizando recursão.
</p>

<p>
A gramática da linguagem é fornecida juntamente com este documento. A gramática pode ser livremente alterada, desde que a linguagem reconhecida permaneça a mesma.
</p>

<p>
As próximas seções exemplificam os conceitos básicos da linguagem \(\mu\)mML.
</p>
</div>

<div id="outline-container-org07958e4" class="outline-3">
<h3 id="org07958e4">Exemplos Básicos</h3>
<div class="outline-text-3" id="text-org07958e4">
<p>
Exemplos podem ser encontrados na pasta <a href="./examples/">exemples</a> e <a href="./inputs/">inputs</a> .
</p>

<p>
Exemplos de entradas <b>com erro</b> podem ser encontradas em <a href="./errors">errors</a> .
</p>
</div>

<div id="outline-container-org42253c7" class="outline-4">
<h4 id="org42253c7">Hello World</h4>
<div class="outline-text-4" id="text-org42253c7">
<pre class="example">
def main =
    print "Ola Mundo!"
</pre>
</div>
</div>

<div id="outline-container-orgc0054a9" class="outline-4">
<h4 id="orgc0054a9">Entrada/Saída</h4>
<div class="outline-text-4" id="text-orgc0054a9">
<ul class="org-ul">
<li>Funções de leitura <code>read_string</code>, <code>read_int</code>, <code>read_char</code> e <code>read_float</code> não recebem parâmetros. Apenas funções especiais em \(\mu\)mML podem receber 0 parâmetros.</li>
<li>A função de saída <code>print</code> aceita como parâmetro qualquer tipo básico (bool, char, int, float), além do tipo especial <i>string</i>.</li>
<li>O operador <code>::</code> concatena sequências de mesmo tipo base.</li>
<li>O comando <code>let</code> declara símbolos que armazenam resultados de funções ou outras operações.</li>
<li>O símbolo especial <code>_</code> nunca é armazenado. No exemplo, o retorno da função print é descartado.</li>
</ul>

<pre class="example">
def main =
let _ = print "Digite seu nome: ",
    name = read_string _ ,
    _ = print "Digite sua idade: ",
    idade = read_int _
in
    print "Olá, " :: name :: ", voce tem " :: (str idade) :: " anos" :: ['\n']
</pre>
</div>
</div>

<div id="outline-container-orgb88dee1" class="outline-4">
<h4 id="orgb88dee1">Escopo</h4>
<div class="outline-text-4" id="text-orgb88dee1">
<ul class="org-ul">
<li>Um comando <code>let</code> cria um novo <i>escopo</i> para símbolos. Símbolos podem ser redefinidos dentro de um novo escopo &#x2013; mas nunca no mesmo.</li>
</ul>

<pre class="example">
def main =
let x = 1                   // x = 1
in let x = x + 1            // x' = x + 1 = 2
   in let x = x + 1         // x'' = x' + 1 = 2
      in x                  // retorna 3
</pre>
</div>
</div>

<div id="outline-container-org0154c20" class="outline-4">
<h4 id="org0154c20">Tipos</h4>
<div class="outline-text-4" id="text-org0154c20">
<p>
\(\mu\)mML é uma linguagem fortemente tipada, porém não há a necessidade de declarar o <i>tipo</i> dos símbolos explicitamente
</p>

<pre class="example">
def main =
  let x = 1,              // x tem tipo int
      y = 'c',            // y tem tipo char
      z = 1.4,            // z tem tipo float
      s = "abc",          // s tem tipo char[], sequencia
      f1 = x + z,         // f1 tem tipo float
      i1 = x + y,         // i1 tem tipo int
      s2 = [y],           // s2 tem tipo char[]
      s3 = [s2],          // s3 tem tipo char[][]
      s4 = s2 :: s,       // s4 tem tipo char[]
      b0 = true &amp;&amp; false, // b0 tem tipo bool
      b1 = y || z,        // b1 tem tipo bool
      b2 = s || s2,       // b2 tem tipo bool
      f2 = float x,       // f2 tem tipo float
      c1 = char z         // c1 tem tipo char
in
  print b1
</pre>

<pre class="example">
def main =
let a = if true then 'a' else 1,        // tipo int
    b = if false then 1 else 1.2,       // tipo float
    c = if true then true else 0,       // tipo bool
    d = if false then nil else "a",     // tipo char[]
    e = char if false then 97 else 98   // tipo char
in {a, b, c, d, e}
</pre>
</div>
</div>

<div id="outline-container-orgd244d51" class="outline-4">
<h4 id="orgd244d51">Controle de Fluxo</h4>
<div class="outline-text-4" id="text-orgd244d51">
<p>
O controle de fluxo é feito com a declaração <code>if</code>. Porém, um <i>if</i> de \(\mu\)mML retorna o valor que resulta da sua avaliação.
</p>

<pre class="example">
def main =
  let x = read_int _
  in
    let y = if x == 0
            then 10
            else 11
    in
      print y + 10
</pre>

<pre class="example">
def main =
let a = if true then 'a' else 1,        // tipo int
    b = if false then 1 else 1.2,       // tipo float
    c = if true then true else 0,       // tipo bool
    d = if false then nil else "a",     // tipo char[]
    e = char if false then 97 else 98   // tipo char
in {a, b, c, d, e}
</pre>
</div>
</div>

<div id="outline-container-orgfd44de0" class="outline-4">
<h4 id="orgfd44de0">Funções</h4>
<div class="outline-text-4" id="text-orgfd44de0">
<p>
Funções não precisam declarar seu tipo de retorno, pois ele é <b>deduzido</b> a partir da expressão da função
</p>

<pre class="example">
// ping_ retorna int
def ping_ cur : int, limit : int =
   if cur &lt; limit
   then let _ = print "Ping " :: (str cur) :: ['\n']
        in
          ping_ cur + 1 limit // Retorna o que ping_ retornar
   else
     limit                    // Retorna int

// ping retorna o que ping_ retornar (int)
def ping limit : int = ping_ 0 limit

def main =
let limit = read_int _
in
  ping limit
</pre>

<p>
Quando necessário, pode-se declarar o tipo de uma função antes de sua implementação
</p>

<pre class="example">
def ping_ cur : int, limit : int -&gt; int
def pong_ cur : int, limit : int -&gt; int

def ping_ cur : int, limit : int =
if cur == limit
then limit
else let _ = print "Ping " :: (str cur) :: ['\n']
     in pong_ cur limit

def pong_ cur : int, limit : int =
if cur == limit
then limit
else let _ = print "Pong " :: (str cur) :: ['\n']
     in ping_ cur + 1 limit

def main = ping_ 0 10
</pre>
</div>
</div>

<div id="outline-container-org9e96848" class="outline-4">
<h4 id="org9e96848">Operando com Sequências</h4>
<div class="outline-text-4" id="text-org9e96848">
<p>
A maneira principal de operar com sequências em \(\mu\)mML é através de recursão.
</p>

<pre class="example">
def str_capitalize_ s : char[],
                    r : char[] =
if ! s                                               // Se vazia, retorna vazia
then r
else let // _ = print "s=" :: s :: ['\n'],           // Debug, descomentar
         // _ = print "r=" :: r :: ['\n'],           // Debug, descomentar
         h::t = s                                    // quebra em primeiro elemento e resto da lista
     in let up = if h &gt;= 'a' &amp;&amp; h &lt;= 'z'
                 then h - ('a' - 'A')
                 else h
        in str_capitalize_ t (r :: [up])

def str_capitalize s : char[] = str_capitalize_ s ""

def main =
let sin = read_string _
in
  print (str_capitalize sin)
</pre>

<p>
Tipos sequência possuem uma constante especial <code>nil</code> que representa uma sequência vazia de qualquer tipo.
</p>

<pre class="example">
def filtra_positivos_menores_que n : int,
                                 v : int[],
                                 result : int[] =
if ! v then result
else let primeiro :: resto = v
     in
        if primeiro &lt; 0 || !(primeiro &lt; n)
           then filtra_positivos_menores_que n resto result
           else let result = result :: [primeiro]
                in filtra_positivos_menores_que n resto result

def main = filtra_positivos_menores_que 10 [1] :: [-2] :: [100] :: [9] :: [10] nil
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb15c468" class="outline-3">
<h3 id="orgb15c468">Tipos Básicos</h3>
<div class="outline-text-3" id="text-orgb15c468">
<p>
A linguagem possui os seguintes tipos básicos:
</p>
<ul class="org-ul">
<li><code>bool</code> &#x2013; um booleano</li>
<li><code>char</code> &#x2013; um caractere</li>
<li><code>int</code> &#x2013; um inteiro de 32 bits</li>
<li><code>float</code> &#x2013; um número de ponto flutuante de 64 bits</li>
<li>Sequências: &#x2013; Um tipo básico, seguido de <code>[]</code>:
<ul class="org-ul">
<li><code>int[]</code> &#x2013; sequência de ints</li>
<li><code>char[]</code> &#x2013; sequência de caracteres (i.e. string)</li>
<li><code>float[][]</code> &#x2013; sequência de sequência de floats (array bi-dimensional)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf55e9ab" class="outline-3">
<h3 id="orgf55e9ab">Literais</h3>
<div class="outline-text-3" id="text-orgf55e9ab">
<p>
A linguagem suporta os seguintes literais em seu código:
</p>
<ul class="org-ul">
<li><b>Literais Booleanos</b>:
<ul class="org-ul">
<li><code>true</code> e <code>false</code></li>
</ul></li>
<li><b>Literais Inteiros</b>:
<ul class="org-ul">
<li><i>Números decimais</i> com ou sem sinal (<code>123</code>, <code>-123</code>, <code>+123</code>)</li>
<li><i>Números Hexadecimais</i> positivos (<code>0x123</code>, <code>0xaf123</code>)</li>
<li><i>Números Binários</i> positivos (<code>10b</code>, <code>11101b</code>)</li>
</ul></li>
<li><b>Literais Reais</b>
<ul class="org-ul">
<li><i>Números com ponto decimal</i> (<code>123.01</code>, <code>-123.09</code>)</li>
<li><i>Números com expoente</i> (<code>123.01E11</code>, <code>123.09E-10</code>)</li>
</ul></li>
<li><b>Literais String</b>
<ul class="org-ul">
<li>Sequências de caracteres entre aspas duplas (<code>"abc"</code>)</li>
<li>Caracteres com escape entre aspas ("abc\noutralinha" )</li>
</ul></li>
<li><b>Literal Char</b>:
<ul class="org-ul">
<li>Um único caractere entre aspas simples (<code>'a'</code>)</li>
<li>Caracteres com escape entre aspas simples ('\\')</li>
</ul></li>
<li><b>Literal Expecial Nulo</b>
<ul class="org-ul">
<li>O literal <code>nil</code>, que representa uma sequência vazia.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org6db33e2" class="outline-3">
<h3 id="org6db33e2">Expressões Booleanas</h3>
<div class="outline-text-3" id="text-org6db33e2">
<p>
As seguintes expressões booleanas são aceitas na linguagem:
</p>
<ul class="org-ul">
<li>Resultado nulo ou não nulo: Se o resultado de uma expressão armazena um valor, então a expressão é <i>verdadeira</i>. Caso o resultado for <code>nil</code>, então a expressão será <i>falsa</i>.</li>
<li>Expressões entre parênteses</li>
<li>Expressões negadas &#x2013; Operador <code>!</code></li>
<li>Igualdade/Inigualdade: &#x2013; Operadores <code>==</code> e <code>!=</code></li>
<li>Operador Lógico <b>E</b> &#x2013; <code>&amp;&amp;</code></li>
<li>Operador Lógico <b>OU</b> &#x2013; <code>||</code></li>
</ul>

<p>
A precedência de operadores segue o padrão esperado para linguagens como <i>Java</i> e <i>C</i>: Negação, Igualdade/Inigualdade, E/OU lógico, com parênteses para alterar a ordem de avaliação.
</p>

<p>
Exemplos:
</p>
<div class="org-src-container">
<pre class="src src-C">a || b

<span style="color: #3a81c3;">(</span>a == b<span style="color: #3a81c3;">)</span> || c <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">parenteses desnecessario</span>

a == <span style="color: #3a81c3;">(</span>b || c<span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">parenteses necessario</span>

<span style="color: #4e3163;">!</span><span style="color: #3a81c3;">(</span>c == a<span style="color: #3a81c3;">)</span>

c <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">C, uma lista, &#233; nao vazio?</span>

<span style="color: #4e3163;">!</span>c <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">C, uma lista, &#233; vazia?</span>

<span style="color: #4e3163;">!</span><span style="color: #3a81c3;">(</span>a || b<span style="color: #3a81c3;">)</span>

</pre>
</div>

<p>
Expressões booleanas podem ser utilizadas como condicional no comando <code>if</code>, mas também podem ter seu resultado "atribuído" a símbolos:
</p>

<pre class="example">
def main =
let a = "abc" || nil,           // nil -&gt; false, char[] -&gt; bool
    b = "abc" || 1,             // int -&gt; bool, char[] -&gt; bool
    c = 'a' || 9.5,             // basic types -&gt; bool
    a2 = "abc" &amp;&amp; nil,
    b2 = "abc" &amp;&amp; 1,
    c2 = 'a' &amp;&amp; 9.5,
    v2 = 1 + int true,           // coercao falha, mas cast funciona,
    v3 = (int (!v2 &amp;&amp; c2)) * 10  // deve ser igual a 0
in
   { a &amp;&amp; b &amp;&amp; c,      // Sempre verdadeiro
     a2 &amp;&amp; b2 &amp;&amp; c2,   // Sempre falso
     v2,               // deve ser 2,
     v3                // deve ser 10
   }
</pre>
</div>
</div>

<div id="outline-container-orgbf1a4ba" class="outline-3">
<h3 id="orgbf1a4ba">Operadores Relacionais</h3>
<div class="outline-text-3" id="text-orgbf1a4ba">
<p>
Os operadores relacionais comparam dois <b>tipos básicos</b> e retornam um valor booleano
</p>

<ul class="org-ul">
<li>Menor e Menor ou Igual: <code>&lt;</code> , <code>&lt;=</code></li>
<li>Maior e Maior ou Igual: <code>&gt;</code>, <code>&gt;=</code></li>
<li>Igual: <code>==</code></li>
<li>Diferente: <code>!=</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-fsharp">a == <span style="color: #4e3163;">1</span>

x &lt;= <span style="color: #4e3163;">2</span> + <span style="color: #4e3163;">1</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org26e9481" class="outline-3">
<h3 id="org26e9481">Expressões Aritméticas</h3>
<div class="outline-text-3" id="text-org26e9481">
<p>
As expressões aritméticas são as operações aritméticas básicas de linguagens de programação:
</p>
<ul class="org-ul">
<li>Soma: <code>+</code></li>
<li>Subtração: <code>-</code></li>
<li>Multiplicação: <code>*</code></li>
<li>Divisão: <code>/</code></li>
<li>Resto da Divisão: <code>%</code></li>
</ul>

<p>
A precedência de operadores garante que Exponenciação tem prioridade sobre Multiplicação e Divisão, que por sua vez têm prioridade sobre Soma e Subtração.
</p>

<p>
Exemplos:
</p>
<div class="org-src-container">
<pre class="src src-python">a + <span style="color: #4e3163;">2</span>

a * b * c / d

<span style="color: #3a81c3;">(</span>a + b<span style="color: #3a81c3;">)</span> * <span style="color: #4e3163;">2</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf74c28e" class="outline-3">
<h3 id="orgf74c28e">Condicional <i>if</i></h3>
<div class="outline-text-3" id="text-orgf74c28e">
<p>
A estrutura <i>if</i> da linguagem tem a seguinte forma:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">if</span> boolexpr
<span style="color: #3a81c3; font-weight: bold;">then</span> expr1
<span style="color: #3a81c3; font-weight: bold;">else</span> expr2
</pre>
</div>

<p>
O comportamento é como esperado: Se a espressão <i>boolexpr</i> for <i>verdadeira</i>, é executado a primeira expresão; caso contrário, a segunda.
</p>

<p>
Uma diferença do <i>if</i> da \(\mu\)mML para o <i>if</i> de linguagens imperativas é que ele é uma <i>expressão</i>: o <i>if</i> <b>retorna</b> o resultado da expressão avaliada. Ou seja, o código
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">if</span> x == <span style="color: #4e3163;">1</span>
<span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #4e3163;">10</span>
<span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #4e3163;">20</span>
</pre>
</div>

<p>
seria equivalente ao seguinte código em C:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #ba2f59; font-weight: bold;">int</span> <span style="color: #6c3163; font-weight: bold;">if_eval_1</span><span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">int</span> <span style="color: #715ab1;">b</span>, <span style="color: #ba2f59; font-weight: bold;">int</span> <span style="color: #715ab1;">r1</span>, <span style="color: #ba2f59; font-weight: bold;">int</span> <span style="color: #715ab1;">r2</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>b<span style="color: #6c3163;">)</span>
       <span style="color: #3a81c3; font-weight: bold;">return</span> r1;
    <span style="color: #3a81c3; font-weight: bold;">else</span>
       <span style="color: #3a81c3; font-weight: bold;">return</span> r2;
<span style="color: #3a81c3;">}</span>

...

r = if_eval_1<span style="color: #3a81c3;">(</span>x == <span style="color: #4e3163;">1</span>, <span style="color: #4e3163;">10</span>, <span style="color: #4e3163;">20</span><span style="color: #3a81c3;">)</span>;
</pre>
</div>

<p>
Uma vez que o <i>if</i> é, ele próprio, uma <i>expressão</i>, ele pode ser utilizado dentro de expressões booleanas ou aritméticas. A expresão:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> x == <span style="color: #4e3163;">0</span> <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #4e3163;">10</span> * x <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #4e3163;">20</span> / x<span style="color: #3a81c3;">)</span> * <span style="color: #4e3163;">2</span>
</pre>
</div>

<p>
retorna \(10 * x * 2\) quando <code>x</code> é zero e \((20 / x) * 2\) quando x é diferente de zero.
</p>

<p>
Uma vez que a condição do if é uma <i>expressão</i>, podemos utilizar parênteses, igualdades, operadores lógicos, etc.
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>x == <span style="color: #4e3163;">0</span> || z<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #3a81c3; font-weight: bold;">if</span> z
     <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #3a81c3;">(</span>z * <span style="color: #4e3163;">10</span> + <span style="color: #4e3163;">2</span><span style="color: #3a81c3;">)</span>
     <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3;">(</span><span style="color: #4e3163;">50</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #4e3163;">10</span>
</pre>
</div>

<p>
<b>Observação</b>: Em \(\mu\)mML, o <i>else</i> <b>não é opcional</b>. Se não há resultado a ser retornado quando a condição for <i>falsa</i>, então deve-se retornar um valor padrão.
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">if</span> x == <span style="color: #4e3163;">0</span>
<span style="color: #3a81c3; font-weight: bold;">then</span> x * <span style="color: #4e3163;">2</span>
<span style="color: #3a81c3; font-weight: bold;">else</span> -1
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc784832" class="outline-3">
<h3 id="orgc784832">Declarações de Símbolos</h3>
<div class="outline-text-3" id="text-orgc784832">
<p>
A linguagem é \(\mu\)mML é uma linguagem funcional <i>pura</i>: uma vez que um valor é atribuído a um <i>símbolo</i>, este símbolo não pode ser alterado. Uma ``variável'' em {{mml}}, portanto, não é <i>variável</i> &#x2013; é como uma declaração de constante.
</p>

<p>
A declaração de símbolos é feita com a primitiva <i>let</i>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #4e3163;">1</span> * <span style="color: #4e3163;">2</span> + y
<span style="color: #3a81c3; font-weight: bold;">in</span>
  x * <span style="color: #4e3163;">2</span> / <span style="color: #4e3163;">10</span>
</pre>
</div>

<p>
A primitiva <i>let</i> pode declarar vários símbolos. Para isso, deve-se utilizar vírgula:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #4e3163;">1</span>,
    y = x + <span style="color: #4e3163;">2</span>,
    z = x * y
<span style="color: #3a81c3; font-weight: bold;">in</span>
   y + <span style="color: #4e3163;">1</span> + z
</pre>
</div>

<p>
Um símbolo declarado <b>sempre</b> deve receber um valor resultante de uma <b>expressão</b>. Uma vez que um <i>if</i> é uma expressão, ele pode ser utilizado no lado direito da igualdade durante um <i>let</i>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #3a81c3; font-weight: bold;">if</span> z &amp;&amp; t
        <span style="color: #3a81c3; font-weight: bold;">then</span> z * t             <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ambos verdade, pode multiplicar</span>
        <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">if</span> z <span style="color: #3a81c3; font-weight: bold;">then</span> z * <span style="color: #4e3163;">10</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">apenas z</span>
        <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">if</span> t <span style="color: #3a81c3; font-weight: bold;">then</span> t * <span style="color: #4e3163;">10</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">apenas t</span>
        <span style="color: #3a81c3; font-weight: bold;">else</span> -1                <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">nenhum</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
   <span style="color: #3a81c3; font-weight: bold;">if</span> x
   <span style="color: #3a81c3; font-weight: bold;">then</span> x * <span style="color: #4e3163;">100</span>                <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x nao recebeu nil</span>
   <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #4e3163;">0</span>                      <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x recebeu 0</span>
</pre>
</div>

<p>
Assim como o <i>if</i>, o <i>let</i> é, também, uma <b>expressão</b> e, portanto, retorna valor:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> x = <span style="color: #4e3163;">100</span> <span style="color: #3a81c3; font-weight: bold;">in</span> x * x * x * x<span style="color: #3a81c3;">)</span> == <span style="color: #4e3163;">100</span>
<span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #3a81c3; font-weight: bold;">false</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">100^4 eh 100 ?! nunca deveria retornar false</span>
<span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">true</span>   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">sempre deveria retrnar true</span>
</pre>
</div>

<p>
O <b>escopo</b> de qualquer símbolo está restrito à expressão associada ao <i>in</i> do <i>let</i>. O seguinte trecho de código deveria retornar \(38\):
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #4e3163;">10</span>
<span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">na proxima expressao, x eh 10</span>
   x + <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> x = <span style="color: #4e3163;">20</span>
        <span style="color: #3a81c3; font-weight: bold;">in</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">na proxima expressao, x eh 20</span>
          x - <span style="color: #4e3163;">2</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Aqui x vale 20, 20 - 2 = 18</span>
       <span style="color: #3a81c3;">)</span>
     + x <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">aqui x ainda eh 10</span>
</pre>
</div>

<p>
A seguinte expressão retorna 20:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #4e3163;">10</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
  <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #4e3163;">20</span>
  <span style="color: #3a81c3; font-weight: bold;">in</span>
    x
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf6b128f" class="outline-3">
<h3 id="orgf6b128f">Chamadas de Função</h3>
<div class="outline-text-3" id="text-orgf6b128f">
<p>
Para invocar uma função em \(\mu\)mML, deve-se utilizar o nome da função seguido de seus parâmetros. O código a seguir chama a função <code>funct</code> com os parâmetros <code>a</code>, <code>b</code> e <code>c</code>.
</p>
<div class="org-src-container">
<pre class="src src-fsharp">funct a b c
</pre>
</div>

<p>
Parâmetros de uma função podem ser resultado de expressões. O seguinte código chama a função <code>funct</code> com os parâmetros \(x + 1\), \(x - 2\) e \(x * 2\):
</p>
<div class="org-src-container">
<pre class="src src-fsharp">funct x + <span style="color: #4e3163;">1</span> x - <span style="color: #4e3163;">2</span> x * <span style="color: #4e3163;">2</span>
</pre>
</div>

<p>
Uma vez que os parâmetros são expressões, pode-se utilizar parênteses para isolá-los no código:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">funct <span style="color: #3a81c3;">(</span> x + <span style="color: #4e3163;">1</span> <span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">(</span> x - <span style="color: #4e3163;">2</span> <span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">(</span> x * <span style="color: #4e3163;">2</span> <span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
Esta sintáxe de chamada de função pode introduzir ambiguidades: O seguinte código poderia ser interpretado como a chamada da função <code>print_results</code> com 3 parâmetros ou como a chamada da função <code>print_results</code> com 2 parâmetros, um deles o resultado da função <code>funct</code> ou com apenas um resultado.
</p>
<div class="org-src-container">
<pre class="src src-fsharp">print_results funct <span style="color: #4e3163;">1</span> <span style="color: #4e3163;">2</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">[1] print_results (funct) (1) (2)</span>
                        <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ou</span>
                        <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">[2] print_results (funct 1)  (2)</span>
                        <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ou</span>
                        <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">[3] print_results (funct 1 2)</span>
</pre>
</div>

<p>
Esta ambiguidade deve ser resolvida para o primeiro caso (i.e. print_results com 3 parâmetros). Para expressar qualquer outra alternativa, o programa deve incluir os parênteses adequadamente.
</p>

<p>
A sintaxe da chamada de função também fica ambígua no caso de funções que não esperam nenhum parâmetro. A função <code>read_int</code>, que lê um inteiro da entrada, não precisa de nenhum parâmetro. Nesse caso, deve-se utilizar o símbolo especial <code>_</code> (<i>underscore</i>) que indica ``nenhum parâmetro'':
</p>
<div class="org-src-container">
<pre class="src src-fsharp">read_int _
</pre>
</div>

<p>
A chamada de uma função também é uma <i>expressão</i>. Assim, podemos atribuir os resultados de uma função a símbolos e utilizar os resultados dentro de expressões:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = read_int _,
    y = funct x
<span style="color: #3a81c3; font-weight: bold;">in</span>
  print_results y + <span style="color: #3a81c3;">(</span>do_something x<span style="color: #3a81c3;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">if</span> funct <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> x == <span style="color: #4e3163;">0</span> <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #4e3163;">10</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #4e3163;">20</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #4e3163;">10</span>
<span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #4e3163;">20</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb72753" class="outline-3">
<h3 id="orgfb72753">Declaração de Funções</h3>
<div class="outline-text-3" id="text-orgfb72753">
<p>
Uma função na linguagem \(\mu\)mML é declarada com a primitiva <code>def</code>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def print_results r : <span style="color: #ba2f59; font-weight: bold;">int</span> =
   print <span style="color: #3a81c3;">(</span>concat <span style="color: #2d9574;">"Resultado: "</span> <span style="color: #6c3163;">(</span>str r<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
Os parâmetros de uma função devem sempre possuir tipos definidos após o símbolo <code>:</code> .
</p>

<p>
Pode-se declarar um cabeçalho para a função para definir claramente qual o tipo de retorno. A declaração do tipo de retorno, no entanto, é <i>opcional</i> &#x2013; o tipo de retorno de uma função deve ser <b>deduzido</b> a partir da expressão de retorno.
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def print_results r -&gt; int
</pre>
</div>

<p>
A declaração de tipos de retorno, no entanto, é necessária para deduzir o tipo de funções <i>mutuamente recursivas</i>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def f1 a : <span style="color: #ba2f59; font-weight: bold;">int</span>, b : <span style="color: #ba2f59; font-weight: bold;">float</span> -&gt; float
def f2 a : <span style="color: #ba2f59; font-weight: bold;">int</span>, b : <span style="color: #ba2f59; font-weight: bold;">float</span> -&gt; float

def f1 a : <span style="color: #ba2f59; font-weight: bold;">int</span>, b : <span style="color: #ba2f59; font-weight: bold;">float</span> =
    <span style="color: #3a81c3; font-weight: bold;">if</span> a != <span style="color: #4e3163;">0</span>
    <span style="color: #3a81c3; font-weight: bold;">then</span> f2 a
            b + b
    <span style="color: #3a81c3; font-weight: bold;">else</span> b

def f2 a : <span style="color: #ba2f59; font-weight: bold;">int</span>, b : <span style="color: #ba2f59; font-weight: bold;">float</span> =
    f1 <span style="color: #3a81c3;">(</span>a - <span style="color: #4e3163;">1</span><span style="color: #3a81c3;">)</span> b
</pre>
</div>

<p>
Uma função não possui a palavra chave <b>returns</b>. O retorno é sempre o resultado de uma <b>expressão</b> &#x2013; e o tipo de retorno de uma função é definido pelo resultado da expressão.
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">media 1 devolve a media de 3. O tipo de retorno eh int</span>
def media1 a : <span style="color: #ba2f59; font-weight: bold;">int</span>,
           b : <span style="color: #ba2f59; font-weight: bold;">int</span>,
           c : <span style="color: #ba2f59; font-weight: bold;">int</span> =
    <span style="color: #3a81c3;">(</span>a + b + c<span style="color: #3a81c3;">)</span> / <span style="color: #4e3163;">3</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">resultado da divisao eh float, entao media2 devolve float</span>
def media2 a : <span style="color: #ba2f59; font-weight: bold;">int</span>,
           b : <span style="color: #ba2f59; font-weight: bold;">int</span>,
           c : <span style="color: #ba2f59; font-weight: bold;">int</span> =
    <span style="color: #3a81c3;">(</span>a + b + c<span style="color: #3a81c3;">)</span> / <span style="color: #4e3163;">3</span>.<span style="color: #4e3163;">0</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">express&#227;o booleana, resultado &#233; bool</span>
def andPred a : <span style="color: #ba2f59; font-weight: bold;">bool</span>, b : <span style="color: #ba2f59; font-weight: bold;">bool</span> = a &amp;&amp; b
</pre>
</div>

<p>
O <i>corpo</i> de uma função é sempre uma expressão. Assim, pode-se utilizar <i>if</i> e <i>let</i> dentro de uma função:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def max2int a : <span style="color: #ba2f59; font-weight: bold;">int</span>,
            b : <span style="color: #ba2f59; font-weight: bold;">int</span> =
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>a &gt; b<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">then</span> a
    <span style="color: #3a81c3; font-weight: bold;">else</span> b
</pre>
</div>

<p>
Toda função retorna algum valor. Uma função de nome <code>print</code>, por exemplo, pode retornar um valor inteiro indicando quantos símbolos foram colocados na tela.
</p>

<p>
Quando o valor de uma função não necessitar ser armazenado, pode-se, no <code>let</code>, utilizar o símbolo especial <code>_</code>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = read_int _,
    _ = print_int x + <span style="color: #4e3163;">1</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ignora o resultado de print</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
  x * <span style="color: #4e3163;">10</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a9bb81" class="outline-3">
<h3 id="org9a9bb81">Funções Especiais</h3>
<div class="outline-text-3" id="text-org9a9bb81">
<p>
Algumas funções são consideradas especiais da linguagem e devem estar disponíveis para o usuário nativamente:
</p>
<ul class="org-ul">
<li><code>read_char _ -&gt; char</code> : Lê um caractere da entrada</li>
<li><code>read_int _ -&gt; int</code> : Lê um int da entrada</li>
<li><code>read_float _ -&gt; float</code> : Lê um float da entrada</li>
<li><code>read_string _ -&gt; char[]</code> : Lê uma string da entrada</li>
<li><code>print a : T -&gt; int</code> : Coloca na tela o valor de <code>a</code>. Aceita qualquer tipo primitivo (<code>char</code>, <code>int</code>, <code>float</code>) e strings (<code>char[]</code>)</li>
<li><code>str a : T -&gt; char[]</code> : Deve funcionar para um tipo T <code>int</code>, <code>char</code>, <code>float</code> e mesmo <code>char[]</code> . Converte o valor a para uma representação em string.</li>
<li><code>nth s : T[], i : int -&gt; T</code> : Recebe como parâmetro uma posição <code>i</code> e uma sequência <code>s</code>, retorna a <code>i</code>-ésima posição do vetor</li>
<li><code>let_nth s : T[], i : int, val : T -&gt; T[]</code> : Recebe como parâmetro uma sequência <code>s</code>, uma posição <code>i</code> e um valor <code>val</code>. Retorna uma nova sequência onde a posição <code>i</code> foi alterada para <code>val</code>.</li>
<li><p>
<code>length v : T[] -&gt; int</code> : retorna a quantidade de elementos de uma sequência.
</p>

<p>
<b>Obs.:</b> <code>length nil</code> sempre retorna 0.
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org677506d" class="outline-3">
<h3 id="org677506d">Tipos Sequência</h3>
<div class="outline-text-3" id="text-org677506d">
<p>
Um tipo sequência em \(\mu\)mML é equivalente a um vetor ou uma lista em outras linguagens. Toda sequência possui tamanho definido. Uma função especial chamada <code>length</code> é responsável por indicar quantos elementos existem na sequência.
</p>

<p>
Uma sequência é criada utilizando o operador <code>[]</code>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s1</span> = <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">1</span><span style="color: #3a81c3;">]</span>,            <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">sequencia de 1 elemento</span>
    s2 = <span style="color: #3a81c3;">[</span> read_int _ <span style="color: #3a81c3;">]</span>, <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1 elemento, lido da entrada</span>
    s3 = nil             <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">lista vazia</span>
<span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span>length s1<span style="color: #3a81c3;">)</span> +         <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">retorna 1 +</span>
   <span style="color: #3a81c3;">(</span>length s2<span style="color: #3a81c3;">)</span> +         <span style="color: #2aa1ae; background-color: #ecf3ec;">//            </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1 +</span>
   <span style="color: #3a81c3;">(</span>length s3<span style="color: #3a81c3;">)</span>           <span style="color: #2aa1ae; background-color: #ecf3ec;">//                </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
</pre>
</div>

<p>
Sequências podem ser concatenadas utilizando o operador <code>::</code>
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s1</span> = <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">1</span><span style="color: #3a81c3;">]</span>,
    s2 = <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">2</span><span style="color: #3a81c3;">]</span>,
    s3 = <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">3</span><span style="color: #3a81c3;">]</span>,
    s4 = nil,
    c1 = s1 :: s2,   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[1, 2]</span>
    c2 = s3 :: s4,   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[3] :: nil = [3]</span>
    c3 = c1 :: c2    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[1, 2] :: [3] = [1, 2, 3]</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
   length c3 <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">retorna 3</span>
</pre>
</div>

<p>
Uma sequência sempre pode ser quebrada em um <i>início</i>, seguido do <i>resto</i> da lista. A sequência [1, 2, 3] pode ser considerada como o início \(1\), seguido da lista [2, 3]. Uma expressão <i>let</i> permite quebrar a lista em seu início e seu resto com o operador <code>::</code>
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">seq</span> = <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">1</span><span style="color: #3a81c3;">]</span> :: <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">2</span><span style="color: #3a81c3;">]</span> :: <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">3</span><span style="color: #3a81c3;">]</span>,
    h::rest = seq <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">quebra seq em um inicio chamado h</span>
                  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">e uma continuacao chamada rest</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
   h == <span style="color: #4e3163;">1</span> &amp;&amp; <span style="color: #3a81c3;">(</span>length rest<span style="color: #3a81c3;">)</span> == <span style="color: #4e3163;">2</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">sempre devolve true</span>
</pre>
</div>

<p>
Uma lista de de um ou menos elementos sempre produzirá um <i>resto</i> <b>nulo</b>. A função abaixo utiliza isso para calcular o tamanho de uma sequência de inteiros:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def len_int_seq__ count : <span style="color: #ba2f59; font-weight: bold;">int</span>, s : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
   <span style="color: #3a81c3; font-weight: bold;">if</span> !s       <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">! ( length s &gt; 0 )</span>
   <span style="color: #3a81c3; font-weight: bold;">then</span> count <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">nada mais para contar</span>
   <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">let</span> h::t = s
        <span style="color: #3a81c3; font-weight: bold;">in</span>
          len_int_seq__ <span style="color: #3a81c3;">(</span>count + <span style="color: #4e3163;">1</span><span style="color: #3a81c3;">)</span> t

def len_int_seq s : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
    len_int_seq__ <span style="color: #4e3163;">0</span> s
</pre>
</div>

<p>
O seguinte código retorna uma lista com todos os elementos da sequencia maiores que 10:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def filter_gt_10__ ret : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span>, s : <span style="color: #ba2f59; font-weight: bold;">int </span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
    <span style="color: #3a81c3; font-weight: bold;">if</span> !s
    <span style="color: #3a81c3; font-weight: bold;">then</span> ret                                   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">nada mais, retorna ret</span>
    <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">let</span> h::t = s                          <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">quebra em inicio e resto</span>
         <span style="color: #3a81c3; font-weight: bold;">in</span>
           <span style="color: #3a81c3; font-weight: bold;">if</span> h &gt; <span style="color: #4e3163;">10</span>                           <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">maior que 10?</span>
           <span style="color: #3a81c3; font-weight: bold;">then</span> filter_gt_10__ <span style="color: #3a81c3;">(</span>ret :: <span style="color: #6c3163;">[</span>h<span style="color: #6c3163;">]</span> <span style="color: #3a81c3;">)</span> t <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">chama recursivo, incluindo o</span>
                                               <span style="color: #2aa1ae; background-color: #ecf3ec;">//          </span><span style="color: #2aa1ae; background-color: #ecf3ec;">inicio no resultado</span>
           <span style="color: #3a81c3; font-weight: bold;">else</span> filter_gt_10__ ret t           <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">chama recursivo, ignora o inicio</span>

def filter_gt_10 s : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
   filter_gt_10__ nil s
</pre>
</div>

<p>
<b>Observação</b>: Uma <i>string</i> na linguagem \(\mu\)mML é uma sequência de caracteres. Por exemplo, a seguinte função possui tipo de retorno <code class="src src-fsharp">char<span style="color: #3a81c3;">[]</span></code> :
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def stringConstante n : <span style="color: #ba2f59; font-weight: bold;">int</span> =
   <span style="color: #2d9574;">"string"</span>
</pre>
</div>

<p>
O mesmo vale para as operações de desempacotamento de lista, concatenação e criação:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def retString n : <span style="color: #ba2f59; font-weight: bold;">int</span> =
  <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span><span style="color: #2d9574;">'a'</span><span style="color: #3a81c3;">]</span>,     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">a eh tipo char[]</span>
      b = <span style="color: #2d9574;">"bbb"</span>,     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">b eh tipo char[]</span>
      c::d2 = <span style="color: #2d9574;">"cdd"</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">c eh tipo char, d2 eh tipo char[]</span>
  <span style="color: #3a81c3; font-weight: bold;">in</span>
    a :: b :: <span style="color: #3a81c3;">[</span>c<span style="color: #3a81c3;">]</span> :: d2 <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">retorna ['a', 'b', 'b', 'b', 'c', 'd', 'd']</span>
                        <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ou "abbbcdd"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb96968" class="outline-3">
<h3 id="orgfb96968">Conversão entre Tipos</h3>
<div class="outline-text-3" id="text-orgfb96968">
<p>
Quando for necessário converter um tipo primitivo para outro tipo primitivo, devemos usar uma operação de <i>cast</i>. Em \(\mu\)mML, um cast funciona como uma chamada de função cujo nome é o tipo destino. <code class="src src-fsharp">int <span style="color: #4e3163;">0</span>.<span style="color: #4e3163;">2</span></code> converte para inteiro o valor em ponto flutuante 0.2 .
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">y</span> = <span style="color: #4e3163;">2</span>.<span style="color: #4e3163;">2</span>,
    x = int y <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x = 2</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
   x * <span style="color: #4e3163;">10</span>
</pre>
</div>

<p>
A conversão de tipos pode ser útil quando queremos forçar um retorno de função para um tipo específico:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def avg2 a : <span style="color: #ba2f59; font-weight: bold;">int</span>, b : <span style="color: #ba2f59; font-weight: bold;">int</span>, round : <span style="color: #ba2f59; font-weight: bold;">bool</span> =
   <span style="color: #3a81c3; font-weight: bold;">if</span> round
   <span style="color: #3a81c3; font-weight: bold;">then</span>
      float <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>a + b<span style="color: #6c3163;">)</span> / <span style="color: #4e3163;">2</span><span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">calcula (a+b)/2, que eh int, mas devolve como float</span>
   <span style="color: #3a81c3; font-weight: bold;">else</span>
      <span style="color: #3a81c3;">(</span>a + b<span style="color: #3a81c3;">)</span> / <span style="color: #4e3163;">2</span>.<span style="color: #4e3163;">0</span>       <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">calcula (a+b)/2.0, float</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-fsharp">def sum__ res : <span style="color: #ba2f59; font-weight: bold;">int</span> , seq : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
    <span style="color: #3a81c3; font-weight: bold;">if</span> !seq
    <span style="color: #3a81c3; font-weight: bold;">then</span> res
    <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">let</span> h::t = seq
         <span style="color: #3a81c3; font-weight: bold;">in</span> sum__ <span style="color: #3a81c3;">(</span>res + h<span style="color: #3a81c3;">)</span> t

def sum seq : <span style="color: #ba2f59; font-weight: bold;">int </span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
    sum__ <span style="color: #4e3163;">0</span> seq

def avg_seq seq : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
   <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">n</span> = length seq, <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">int</span>
       s = sum seq     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">int</span>
   <span style="color: #3a81c3; font-weight: bold;">in</span>
      s / <span style="color: #3a81c3;">(</span>float n<span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">devolve uma soma inteira</span>
                    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">dividida por um float</span>
                    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-&gt; retorna float</span>
</pre>
</div>

<p>
As seguintes conversões de tipos são aceitas na linguagem \(\mu\)mML:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Tipo Origem</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Tipo Destino</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Obs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Bool</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Char</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">0 se falso, 1 se verdadeiro</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Bool</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Int</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Bool</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Float</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Char</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Int</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">Devolve o número da tabela ASCII correspondente ao caractere</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Char</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Float</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Inteiro</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Float</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">Número em ponto flutuante com 0s depois da vírgula (1 &rarr; 1.0)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Float</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Inteiro</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">Número inteiro descartando a parte fracionária. Pode perder precisão (1.9 &rarr; 1). Compilador deve alertar (<i>Warning</i>)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Float</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Char</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">Caractere, convertido da tabela ASCII a partir da parte inteira do número</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Int</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Char</td>
<td class="org-left">&checkmark;</td>
<td class="org-left">Devolve o caractere associado ao valor da tabela ASCII</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Booleano</td>
<td class="org-left">&checkmark;</td>
<td class="org-left"><i>true</i> se não-vazia. <i>false</i> caso contrário</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Qualquer</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Booleano</td>
<td class="org-left">&checkmark;</td>
<td class="org-left"><i>false</i> se zero; <i>true</i> caso contrário</td>
</tr>
</tbody>
</table>
<p>
<b>Obs.:</b> Casts não são definidos para tipos sequência, tuplas ou classes, apenas para tipos básicos.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">intToString__ 512 10 "" -&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">intToString__ 51 10 "2" -&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//         </span><span style="color: #2aa1ae; background-color: #ecf3ec;">intToString__ 5 10 "12" -&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//           </span><span style="color: #2aa1ae; background-color: #ecf3ec;">intToString__ 0 10 "512" -&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//             </span><span style="color: #2aa1ae; background-color: #ecf3ec;">"512"</span>

def intToString__ x : <span style="color: #ba2f59; font-weight: bold;">int</span>,
                  b : <span style="color: #ba2f59; font-weight: bold;">int</span>,
                  r : <span style="color: #ba2f59; font-weight: bold;">char </span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> =
  <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">lastDigit</span> = x - <span style="color: #3a81c3;">(</span>x / b<span style="color: #3a81c3;">)</span> * b,        <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x % b, x = 51, lastDigit = 1</span>
      rest = x / b,                       <span style="color: #2aa1ae; background-color: #ecf3ec;">//         </span><span style="color: #2aa1ae; background-color: #ecf3ec;">rest = 5</span>
      r1 = <span style="color: #3a81c3;">[</span> <span style="color: #2d9574;">'0'</span> + char lastDigit <span style="color: #3a81c3;">]</span> :: r  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">r1 = "2", ['1'] :: ['2'] = "12"</span>
  <span style="color: #3a81c3; font-weight: bold;">in</span>
    <span style="color: #3a81c3; font-weight: bold;">if</span> rest == <span style="color: #4e3163;">0</span>
    <span style="color: #3a81c3; font-weight: bold;">then</span> r1
    <span style="color: #3a81c3; font-weight: bold;">else</span> intToString__ rest b r1

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">funciona para base &lt; 10</span>
def intToStringBase x : <span style="color: #ba2f59; font-weight: bold;">int</span>, b : <span style="color: #ba2f59; font-weight: bold;">int</span> = intToString__ x b <span style="color: #2d9574;">""</span>

def intToString x : <span style="color: #ba2f59; font-weight: bold;">int</span> = intToStringBase x <span style="color: #4e3163;">10</span>

def charToString c : <span style="color: #ba2f59; font-weight: bold;">char</span> = <span style="color: #3a81c3;">[</span>c<span style="color: #3a81c3;">]</span>

def main =
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s</span> = <span style="color: #2d9574;">"101010"</span>,
    c = <span style="color: #2d9574;">'a'</span>,
    c_ascii = int c, <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">97</span>
    c2 = char <span style="color: #4e3163;">98</span>     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'b'</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
   <span style="color: #3a81c3;">(</span> intToString <span style="color: #4e3163;">101010</span> <span style="color: #3a81c3;">)</span> :: <span style="color: #3a81c3;">(</span>charToString  c2<span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">"101010" :: "b" -&gt; "101010b"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org774cad2" class="outline-3">
<h3 id="org774cad2">Tipos Tupla</h3>
<div class="outline-text-3" id="text-org774cad2">
<p>
Uma <i>tupla</i> é como um vetor que suporta tipos distintos em cada posição. Tuplas são úteis para retornar mais de um valor em uma função.
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def doisRetornos x : <span style="color: #ba2f59; font-weight: bold;">int</span> = <span style="color: #3a81c3;">{</span>x, x + <span style="color: #4e3163;">1</span><span style="color: #3a81c3;">}</span>
</pre>
</div>

<p>
Diferente de um tipo sequência, que pode conter de 0 a n valores, um tipo tupla possui tamanho fixo. O retorno da função acima, por exemplo, é uma tupla de tamanho 2.
</p>

<div class="org-src-container">
<pre class="src src-fsharp">def doisRetornos x : <span style="color: #ba2f59; font-weight: bold;">int</span> -&gt; <span style="color: #3a81c3;">{</span>int, int<span style="color: #3a81c3;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org831a4cd" class="outline-3">
<h3 id="org831a4cd">Tipos Definidos pelo Usuário</h3>
<div class="outline-text-3" id="text-org831a4cd">
<p>
Um tipo definido pelo usuário é algo parecido com <i>structs</i> de C ou <i>classes</i> de C++/Java, etc.
</p>

<p>
A declaração de tipo de usuário é feita com a palavra-chave <code>class</code>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">class</span> MeuTipo =
  campo1 : <span style="color: #ba2f59; font-weight: bold;">int</span>,
  campo2 : <span style="color: #3a81c3;">{</span>char<span style="color: #6c3163;">[]</span>, int<span style="color: #3a81c3;">}</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">, outros : campos</span>
</pre>
</div>

<p>
Para construir uma "instância" de um tipo definido pelo usuário, deve-se usar a palavra chave <code>make</code> em uma expressão. É obrigatório fornecer valor para <b>todos os campos da instância</b>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = make MeuTipo <span style="color: #3a81c3;">{</span><span style="color: #4e3163;">1</span>, <span style="color: #6c3163;">{</span><span style="color: #2d9574;">"string"</span>, length <span style="color: #2d9574;">"string"</span><span style="color: #6c3163;">}</span><span style="color: #3a81c3;">}</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">...</span>
</pre>
</div>

<p>
Pode-se, no entanto, criar uma função "construtora" para um tipo:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def construct_MeuTipo a : <span style="color: #ba2f59; font-weight: bold;">int</span> =
  make MeuTipo<span style="color: #3a81c3;">{</span><span style="color: #4e3163;">1</span>, <span style="color: #6c3163;">{</span><span style="color: #2d9574;">"default"</span>, length <span style="color: #2d9574;">"default"</span><span style="color: #6c3163;">}</span><span style="color: #3a81c3;">}</span>
</pre>
</div>

<p>
O acesso a campos de um tipo definido pelo usuário se faz com a palavra chave <code>get</code>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = make MeuTipo <span style="color: #3a81c3;">{</span><span style="color: #4e3163;">1</span>, <span style="color: #6c3163;">{</span><span style="color: #2d9574;">"string"</span>, length <span style="color: #2d9574;">"string"</span><span style="color: #6c3163;">}</span><span style="color: #3a81c3;">}</span> ,
    f1 = get campo1 x
<span style="color: #3a81c3; font-weight: bold;">in</span>
   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">...</span>
</pre>
</div>

<p>
Não é possível <i>alterar</i> o conteúdo de campos em instâncias já criadas. No entanto, é possível criar uma nova instância de um tipo definido pelo usuário, alterando apenas um dos campos:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = make MeuTipo <span style="color: #3a81c3;">{</span><span style="color: #4e3163;">1</span>, <span style="color: #6c3163;">{</span><span style="color: #2d9574;">"string"</span>, length <span style="color: #2d9574;">"string"</span><span style="color: #6c3163;">}</span><span style="color: #3a81c3;">}</span> ,
    x1 = set campo1 x <span style="color: #4e3163;">2</span>           <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">constroi MeuTipo {2, {"string", 7}}</span>
<span style="color: #3a81c3; font-weight: bold;">in</span>
   <span style="color: #3a81c3;">{</span>get campo1 x, get campo1 x1<span style="color: #3a81c3;">}</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">retorna {1, 2}</span>
   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">...</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9c21f85" class="outline-3">
<h3 id="org9c21f85">Aritmética de Tipos na linguagem \(\mu\)mML</h3>
<div class="outline-text-3" id="text-org9c21f85">
<p>
Na linguagem \(\mu\)mML, tipos são definidos explicitamente
</p>
<ul class="org-ul">
<li>nos parâmetros de uma função</li>
<li>na declaração de tipo de retorno de uma função</li>
<li>na construção de tipos definidos pelo usuário.</li>
</ul>

<p>
Já os tipos de símbolos (equivalenes a variáveis) em \(\mu\)mML são sempre <i>derivados</i> da expressão, em função dos <i>tipos</i> nos parâmetros de uma função.
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = read_int _ <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">tipo de x eh derivado do retorno de read_int</span>
<span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">...</span>
</pre>
</div>

<p>
Torna-se necessário, portanto, <i>inferir</i>, a partir das operações básicas da linguagem e dos tipos dos operandos, quais os serão os tipos resultantes.
</p>

<p>
Na linguagem \(\mu\)mML, os operadores aritméticos devem respeitar a seguinte <i>aritmética de tipos</i>;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lado Esquerdo</th>
<th scope="col" class="org-left">(Operadores)</th>
<th scope="col" class="org-left">Lado Direito</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Resultado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Char</td>
<td class="org-left">+ - / *</td>
<td class="org-left">Char</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Char</td>
</tr>

<tr>
<td class="org-left">Char</td>
<td class="org-left">+ - / *</td>
<td class="org-left">Inteiro</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Inteiro</td>
</tr>

<tr>
<td class="org-left">Inteiro</td>
<td class="org-left">+ - / *</td>
<td class="org-left">Char/Inteiro</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Inteiro</td>
</tr>

<tr>
<td class="org-left">Inteiro</td>
<td class="org-left">+ - / *</td>
<td class="org-left">Float</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Float</td>
</tr>

<tr>
<td class="org-left">Float</td>
<td class="org-left">+ - / *</td>
<td class="org-left">Inteiro/Float</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Float</td>
</tr>
</tbody>
</table>

<p>
Para o operator <code>::</code> (concatenação), a operação só deve ser permitida com tipos base e dimensão <b>idênticas</b>:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lado Esquerdo</th>
<th scope="col" class="org-left">(Operadores)</th>
<th scope="col" class="org-left">Lado Direito</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Resultado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">int[]</td>
<td class="org-left">::</td>
<td class="org-left">int[]</td>
<td class="org-left">&rarr;</td>
<td class="org-left">int[]</td>
</tr>

<tr>
<td class="org-left">int[][]</td>
<td class="org-left">::</td>
<td class="org-left">int[][]</td>
<td class="org-left">&rarr;</td>
<td class="org-left">int[][]</td>
</tr>

<tr>
<td class="org-left">int[][][]</td>
<td class="org-left">::</td>
<td class="org-left">int[][][]</td>
<td class="org-left">&rarr;</td>
<td class="org-left">int[][][]</td>
</tr>

<tr>
<td class="org-left">char[]</td>
<td class="org-left">::</td>
<td class="org-left">char[]</td>
<td class="org-left">&rarr;</td>
<td class="org-left">char[]</td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#x2026;</td>
</tr>

<tr>
<td class="org-left">float[]</td>
<td class="org-left">::</td>
<td class="org-left">float[]</td>
<td class="org-left">&rarr;</td>
<td class="org-left">float[]</td>
</tr>

<tr>
<td class="org-left">int[]</td>
<td class="org-left">::</td>
<td class="org-left">float[]</td>
<td class="org-left">&rarr;</td>
<td class="org-left"><b>ERRO</b></td>
</tr>

<tr>
<td class="org-left">int[]</td>
<td class="org-left">::</td>
<td class="org-left">int[][]</td>
<td class="org-left">&rarr;</td>
<td class="org-left"><b>ERRO</b></td>
</tr>

<tr>
<td class="org-left">char[]</td>
<td class="org-left">::</td>
<td class="org-left">int[]</td>
<td class="org-left">&rarr;</td>
<td class="org-left"><b>ERRO</b></td>
</tr>
</tbody>
</table>

<p>
Todas as operações booleanas devolvem tipo <i>bool</i>. É importante lembrar que uma <i>expressão</i> que devolve <code>int</code> ou <code>float</code> pode ser considerada uma expressão booleana também &#x2013; sendo <i>falsa</i> se seu resultado é 0 e verdadeira, caso contrário. Já listas são convertidas para "verdadeiro" caso sejam não-vazias. <code>nil</code> é sempre avaliado como falso.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lado Esquerdo</th>
<th scope="col" class="org-left">Operadores</th>
<th scope="col" class="org-left">Lado Direito</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Resultado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&amp;&amp;</td>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">true, ambos guardam algum valor</td>
</tr>

<tr>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&amp;&amp;</td>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">false, algum deles é 0 ou <code>nil</code></td>
</tr>

<tr>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&vert;&vert;</td>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">true, algum dos lados guarda valor</td>
</tr>

<tr>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&vert;&vert;</td>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">false, ambos são 0 ou <code>nil</code></td>
</tr>

<tr>
<td class="org-left">Bool</td>
<td class="org-left">&amp;&amp;</td>
<td class="org-left">Bool</td>
<td class="org-left">&rarr;</td>
<td class="org-left">true, ambos são verdadeiros</td>
</tr>

<tr>
<td class="org-left">Bool</td>
<td class="org-left">&amp;&amp;</td>
<td class="org-left">Bool</td>
<td class="org-left">&rarr;</td>
<td class="org-left">false, um dos dois é falso</td>
</tr>

<tr>
<td class="org-left">Bool</td>
<td class="org-left">&vert;&vert;</td>
<td class="org-left">Bool</td>
<td class="org-left">&rarr;</td>
<td class="org-left">true, um dos dois é verdadeiro</td>
</tr>

<tr>
<td class="org-left">Bool</td>
<td class="org-left">&vert;&vert;</td>
<td class="org-left">Bool</td>
<td class="org-left">&rarr;</td>
<td class="org-left">false, um dos dois é falso</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">!</td>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">true, lado direito não armazena valor</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">!</td>
<td class="org-left">Float/Int/Char/Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">false, lado direito armazena valor</td>
</tr>
</tbody>
</table>

<p>
Em uma expressão booleana, pode-se considerar que qualquer símbolo que armazene algo não-nulo é equivalente a <code>true</code>. Isso pode ser obtido através de <i>coearção de tipos</i>.
</p>
</div>

<div id="outline-container-orgd51dd87" class="outline-4">
<h4 id="orgd51dd87">Coerção de Tipos</h4>
<div class="outline-text-4" id="text-orgd51dd87">
<p>
Quando um tipo inteiro for passado como parâmetro para uma função que espera um <i>float</i>, este tipo pode ser convertido automaticamente para float, sem que o usuário do compilador solicite explicitamente o <i>cast</i>. Isso se chama <i>coerção de tipos</i>.
</p>

<p>
As seguintes coerções de tipos são válidas:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Char</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Integer</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Char</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Float</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Integer</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Char</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Integer</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Float</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Float</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Char</td>
<td class="org-left"><b>Deve gerar Warning</b></td>
</tr>

<tr>
<td class="org-left">Float</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Int</td>
<td class="org-left"><b>Deve gerar Warning</b></td>
</tr>

<tr>
<td class="org-left">Char</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Booleano</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Inteiro</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Booleano</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Float</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Booleano</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Sequência</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Booleano</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Booleano</td>
<td class="org-left">&rarr;</td>
<td class="org-left">Int, Char, Float</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
No caso da coerção para <i>booleano</i>, o <i>valor</i> obtido será equivalente a <i>false</i> caso o valor coagido for:
</p>
<ul class="org-ul">
<li>sequência vazia</li>
<li>constante <code>nil</code></li>
<li>Char, Inteiro, Float, com valor 0</li>
</ul>

<p>
O seguinte código deve, portanto, funcionar corretamente:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def media a : <span style="color: #ba2f59; font-weight: bold;">float</span>, b : <span style="color: #ba2f59; font-weight: bold;">float</span> =
    <span style="color: #3a81c3;">(</span>a + b<span style="color: #3a81c3;">)</span> / <span style="color: #4e3163;">2</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(float + float) / int = float / int = float</span>

def main =
    <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = read_int _,
        y = <span style="color: #2d9574;">'z'</span>
    <span style="color: #3a81c3; font-weight: bold;">in</span>
      media x y <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x eh coagido para float , y eh coagido para float</span>
</pre>
</div>

<p>
Uma coerção especial é a da constante nula <code>nil</code> para algum tipo sequência. A constante <code>nil</code> pode ser coagida para qualquer tipo sequência durante chamadas de função ou concatenação de sequências:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def concat a : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> , b : <span style="color: #ba2f59; font-weight: bold;">int</span><span style="color: #3a81c3; font-weight: bold;">[</span><span style="color: #3a81c3;">]</span> = a :: b

def main =
    <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">tmp</span> = <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">1</span><span style="color: #3a81c3;">]</span> :: <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">2</span><span style="color: #3a81c3;">]</span> :: nil  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Coage para int[] por que</span>
                                 <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[1] :: [1] &#233; int</span>
    <span style="color: #3a81c3; font-weight: bold;">in</span> concat tmp nil            <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Coage para int[] por que eh o</span>
                                 <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">que o parametro 2 de concat espera</span>
</pre>
</div>

<p>
A coerção de tipos também deve acontecer durante o "retorno" de if's, para que o retorno seja de algum tipo abrangente o sufuciente para armazenar tanto o retorno do lado <i>verdadeiro</i> quando o do lado <i>falso</i>:
</p>
<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #3a81c3; font-weight: bold;">if</span> a
        <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #4e3163;">5</span>.<span style="color: #4e3163;">2</span>   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">float</span>
        <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #4e3163;">7</span>     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">int</span>
<span style="color: #3a81c3; font-weight: bold;">in</span> x          <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;-- x &#233; do tipo float</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">l</span> = <span style="color: #3a81c3; font-weight: bold;">if</span> a
        <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">1</span><span style="color: #3a81c3;">]</span>   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">tipo int[]</span>
        <span style="color: #3a81c3; font-weight: bold;">else</span> nil   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">tipo QUALQUER[]</span>
<span style="color: #3a81c3; font-weight: bold;">in</span> l       <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;-- x &#233; do tipo int[]</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org42c6841" class="outline-3">
<h3 id="org42c6841">Um Programa em \(\mu\)mML</h3>
<div class="outline-text-3" id="text-org42c6841">
<p>
Um programa em \(\mu\)mML deve possuir uma função chamada <i>main</i> que não recebe nenhum parâmetro. A execução do programa se inicia por esta função:
</p>
<div class="org-src-container">
<pre class="src src-fsharp">def fib x : <span style="color: #ba2f59; font-weight: bold;">int</span> =
    <span style="color: #3a81c3; font-weight: bold;">if</span> x &lt;= <span style="color: #4e3163;">0</span> <span style="color: #3a81c3; font-weight: bold;">then</span> -1 <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0 nao eh valido</span>
    <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">if</span> x == <span style="color: #4e3163;">1</span> <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #4e3163;">1</span>
    <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">if</span> x == <span style="color: #4e3163;">2</span> <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #4e3163;">1</span>
    <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3;">(</span>fib x - <span style="color: #4e3163;">1</span><span style="color: #3a81c3;">)</span> + <span style="color: #3a81c3;">(</span>fib x - <span style="color: #4e3163;">2</span><span style="color: #3a81c3;">)</span>

def main =
    <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">_</span> = print <span style="color: #2d9574;">"Digite um numero : "</span>,
        n = read_int _ ,
        fib_n = fib n
    <span style="color: #3a81c3; font-weight: bold;">in</span>
       <span style="color: #3a81c3; font-weight: bold;">if</span> !fib_n
       <span style="color: #3a81c3; font-weight: bold;">then</span> <span style="color: #3a81c3; font-weight: bold;">let</span> _ = print <span style="color: #2d9574;">"Numero invalido para fibbonaci\n"</span> <span style="color: #3a81c3; font-weight: bold;">in</span> nil
       <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">let</span> _ = print <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Fib de "</span> :: <span style="color: #6c3163;">(</span>str n<span style="color: #6c3163;">)</span> :: <span style="color: #2d9574;">" eh "</span> :: <span style="color: #6c3163;">(</span>str fib_n<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">in</span> nil
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgeb5439f" class="outline-2">
<h2 id="orgeb5439f">Entradas e Árvores de Análise</h2>
<div class="outline-text-2" id="text-orgeb5439f">
<ul class="org-ul">
<li><p>
Exemplo 1
</p>
<pre class="example">
def main = 1
</pre>


<div class="figure">
<p><img src="inputs/main.png" alt="main.png" />
</p>
</div></li>

<li><p>
Exemplo 2
</p>

<pre class="example">
def main = "uma \"\nstring"
</pre>


<div class="figure">
<p><img src="inputs/main2.png" alt="main2.png" />
</p>
</div></li>

<li><p>
Exemplo 3
</p>
<pre class="example">
def main = 0xabfe
</pre>


<div class="figure">
<p><img src="inputs/main3.png" alt="main3.png" />
</p>
</div></li>

<li><p>
Exemplo 4: Funções
</p>
<pre class="example">
def f1 a : int, b : char -&gt; int
def f1 a : int, b : char = a + b

def main = f1 1 'a'
</pre>


<div class="figure">
<p><img src="inputs/fun1.png" alt="fun1.png" />
</p>
</div></li>

<li><p>
Exemplo 5: if
</p>

<pre class="example">
def main = if x == y then x - y else x + y
</pre>


<div class="figure">
<p><img src="inputs/if.png" alt="if.png" />
</p>
</div></li>

<li><p>
Exemplo 6: let
</p>

<pre class="example">
def main =
  let x = 1,
      y = 2
  in
    x + y
</pre>


<div class="figure">
<p><img src="inputs/let.png" alt="let.png" />
</p>
</div></li>

<li><p>
Exemplo 7 : expressões booleanas
</p>
<pre class="example">
def main =
  if x + 1 == 2 &amp;&amp; x - 1 == 0 || y
  then "correto"
  else "wtf"
</pre>

<div class="figure">
<p><img src="inputs/expr1.png" alt="expr1.png" />
</p>
</div></li>

<li><p>
Exemplo 8 : Chamada de Função
</p>

<pre class="example">
def main = funcao1 a + b c + 2 y
</pre>


<div class="figure">
<p><img src="inputs/funcall1.png" alt="funcall1.png" />
</p>
</div></li>

<li><p>
Exemplo 9 : Chamada de Função 2
</p>
<pre class="example">
def main = funcao1 a + b c (funcao2 a b)
</pre>


<div class="figure">
<p><img src="inputs/funcall2.png" alt="funcall2.png" />
</p>
</div></li>

<li><p>
Exemplo 10 : Tuplas
</p>
<pre class="example">
def make_tuple_int x : int, y : int -&gt; {int, int}

def make_tuple_int x : int,
                   y : int =
    {x + 1,
     if x == 0
     then y + 1
     else y + x
    }

def main = make_tuple_int 1 2
</pre>


<div class="figure">
<p><img src="inputs/tuples.png" alt="tuples.png" />
</p>
</div></li>

<li><p>
Exemplo 11 : Tipos Definidos pelo Usuário
</p>
<pre class="example">
class MeuTipo =
  campo1 : int,
  campo4 : {int, int[]}[]

def construct_MeuTipo a : int =
  make MeuTipo {a, {0, nil}}

def funct a : MeuTipo =
  get campo1 make MeuTipo {1, {1, [1]}}
</pre>


<div class="figure">
<p><img src="inputs/custom_types.png" alt="custom_types.png" />
</p>
</div></li>

<li><p>
Exemplo 12 : Listas
</p>
<pre class="example">
def concat a : int[] , b : int[] = a :: b

def main =
   concat ([1] :: [2] :: nil) // Coage para int[] por causa da concatenacao da esquerda
          nil                 // Coage para int[] por que eh o
                              // que o parametro 2 de concat espera
</pre>


<div class="figure">
<p><img src="inputs/lists.png" alt="lists.png" />
</p>
</div></li>

<li><p>
Exemplo 13 : Precedência com operadores booleanos e expressões
</p>
<pre class="example">
def main = if (len arr) == get 0 tup then 0 else 1
</pre>


<div class="figure">
<p><img src="inputs/precedence1.png" alt="precedence1.png" />
</p>
</div></li>

<li><p>
Exemplo 14 : Precedência de operadores booleanos
</p>

<pre class="example">
def f1 a : int = x &amp;&amp; a || x &amp;&amp; b

def f2 a : int = x || a &amp;&amp; x || b
</pre>


<div class="figure">
<p><img src="inputs/precedence_bool.png" alt="precedence_bool.png" />
</p>
</div></li>

<li><p>
Exemplo 15 : Precedência de operadores booleanos
</p>

<pre class="example">
def main = a &amp;&amp; b &amp;&amp; c
</pre>


<div class="figure">
<p><img src="inputs/precedence_bool2.png" alt="precedence_bool2.png" />
</p>
</div></li>

<li><p>
Exemplo 16 : Tipos Sequência
</p>

<pre class="example">
def fun m2 : int[][] = 0

def main = 1
</pre>


<div class="figure">
<p><img src="inputs/seq1.png" alt="seq1.png" />
</p>
</div></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Prof. Rodrigo Kassick</p>
<p class="date">Created: 2017-10-18 qua 17:54</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
